<?xml version="1.0"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">
<chapter id="intro">
  <title>Introduction à Jenkins</title>
  <sect1 id="I_sect11_d1e536">
    <title>Introduction</title>
    <para>L'Intégration Continue, aussi connue sous le terme <indexterm class="startofrange" id="ch01-ci" significance="normal"><primary>IC (Intégration Continue)</primary></indexterm><indexterm id="I_indexterm1_d1e544" significance="normal"><primary>Intégrtion Continue</primary><see>IC</see></indexterm>IC, est l'un des piliers du développement logiciel moderne. En fait
    elle est un véritable tournant — quand l'Intégration Continue est mise en place dans 
    une organisation, elle change radicalement la manière dont les équipes 
    pensent le processus de développement. Elle est capable de permettre et
    d'induire toute une série d'améliorations et de transformations, depuis 
    le régulier build automatisé à la livraison continue en production. Une
    bonne infrastructure d'IC peut fluidifier le processus de développement jusqu'au
    déploiement, aide à détecter et corriger les bogues plus rapidement, fournit
    un écran de contrôle très utile aux développeurs mais aussi aux non-développeurs, et
    poussée à l'extrême, elle permet aux équipes de fournir plus de valeur métier aux utilisateurs finaux.
    Toute équipe de développement professionnelle, quelque soit sa taille, devrait mettre en 
    œuvre l'IC.</para>
  </sect1>
  <sect1 id="intro-sect-intro">
    <title>Les fondamentaux de l'Intégration Continue</title>
    <para>A l'époque des projets en V et des diagrammes de Gantt, avant l'introduction des 
    pratiques de l'IC, une équipe de développement dépensait sans compter son temps et son énergie 
    durant la phase amenant à la livraison et qui portait le nom de Phase d'Intégration. 
    Pendant cette phase, toutes les modifications apportées au code par les développeurs ou de 
    petites équipes étaient rassemblées puis aggrégées et  fusionnées en un produit fonctionnel. 
    Ce travail était dur, intégrant ainsi des mois de modifications qui entraient en conflit. 
    Il était très difficile d'anticiper les problèmes qui allaient
    surgir, et encore plus de les corriger car cela impliquait de retravailler du code qui 
    avait été écrit des semaines, voire des mois auparavant. Ce douloureux processus, plein de
    risques et de dangers, amenait souvent des retards significatifs de livraison, des
    coûts supplémentaires, et au final des clients mécontents. L'Intégration Continue est née
    comme réponse à ces problèmes.</para>
    <para>L'Intégration Continue, dans sa forme la plus simple, se compose d'un outil
    qui surveille les modifications de code dans votre gestionnaire de configuration.
    Dès qu'un changement est détecté, cet outil va automatiquement compiler et tester
    votre application. Si quelquechose se passe mal, l'outil va immédiatement avertir
    les développeurs afin qu'ils puissent immédiatement corriger le problème.</para>
    <para>Mais l'Intégration Continue est bien plus que cela. L'Intégration Continue
    peut aussi suivre la santé de votre code en surveillant la qualité du code et
    les métriques de couverture et ainsi aider à maintenir la dette technique 
    à un niveau bas et à abaisser les coûts de maintenance. Rendre visible publiquement
    les métriques de qualité de code encourage les développeurs à être fiers de la 
    qualité de leur code et à essayer de toujours l'améliorer. Combinée à une suite de tests
    d'acceptance automatisés, l'IC peut aussi se transformer en outil de communication en
    affichant une image claire de l'état des développements en cours. Et elle peut simplifier
    et accélerer la livraison en vous aidant à automatiser le processus de déploiement, vous
    permettant de déployer la dernière version de votre application soit automatiquement soit
    d'un simple click.</para>
    <para>Dans le fond, l'Intégration Continue c'est réduire les risques en fournissant 
    des retours rapides. En premier lieu, de par sa conception elle permet d'identifier et
    de corriger les problèmes d'intégration et les regressions plus rapidement ce qui 
    permet de livrer plus facilement, plus rpaidement et avec moins de bogues.
    En donnant une meilleure visibilité sur l'état du projet à tous les membres de l'équipe,
    techniques comme non-techniques, l'Intégration Continue facilite la communication au sein de
    l'équipe et encourage la collaboration pour résoudre les problèmes ainsi que l'amélioration du
    processus. Et, en automatisant le processus de déploiement, l'Intégration Continue vous permet de
    mettre votre logiciel dans les mains des testeurs et des utilisateurs finaux plus rapidement,
    avec plus de fiabilité et avec moins d'efforts.</para>
    <para>Ce concept de déploiement automatiséest important. En effet, si vous poussez ce
    concept de déploiement automatisé à sa conclusion logique, vous pourriez mettre en
    production tout buildqui passerait sans encombre les tests automtisés nécessaires.
    Cette pratique de déployer en production tous les builds ayant réussi est appelée 
    communément <indexterm id="I_indexterm1_d1e563" significance="normal"><primary>déploiement continu</primary></indexterm> <emphasis>Déploiement <phrase role="keep-together">Continu</phrase></emphasis>.</para>
    <para>Cependant, une approche pure du Déploiement Continu n'est pas toujours souhaitable.
    Par exemple, de nombreux utilisateurs n'apprécieraient pas d'avoir une nouvelle version
    disponible plusieurs fois par semaine et préfereraient un cycle de livraison plus 
    prévisible (et transparent). Des considérations commerciales et marketing peuvent 
    aussi entrer en compte pour déterminer quand une nouvelle version doit être déployée.</para>
    <para>La notion de <emphasis><indexterm id="I_indexterm1_d1e577" significance="normal"><primary>livraison continue</primary></indexterm>Livraison Continue</emphasis> est très proche de cette idée
    de Déploiement Continu en prenant ces considérations en compte. Lors d'une Livraison Continue tout
    build qui a réussi à passer les tests automatisés pertinents et les filtres de la qualité 
    peut <emphasis>virtuellement</emphasis> être déployé en production au moyen d'un <phrase role="keep-together">processus</phrase> 
    lancé par un simple clic, et ainsi se retrouver dans les mains de l'utilisateur final en quelques minutes.
    Cependant, ce processus n'est pas automatique: c'est au métier, plutôt qu'à l'Informatique de 
    décider quel est le moment opportun pour livrer les dernières modifications.</para>
    <?dbfo-need height=”1in”?>
    <para>Ainsi les techniques d'Intégration Continue, et plus particulièrement 
    le Déploiement Continu et la Livraison Continue, permettre d'apporter la
    valeur à l'utilisateur final plus rapidement. Combien de temps faut-il à votre
    équipe pour mettre une petite modification du code en production ? Dans ce temps
    quelle est la part des problèmes qui auraient pu être corrigés plus tôt si vous
    aviez su quelles modifications faisait Joe au bout du couloir ? Quelle part
    est prise par le pénible travail des équipe de la qualité pour tester 
    manuellement ? Combien d'étapes manuelles, dont les secrets sont connus 
    de quelques initiés seulement, sont nécessaires à un déploiement ? L'Intégration
    Continue n'est pas la solution mirace, mais elle permet de rationaliser
    certains de ces problèmes.</para>
    <para>Mais l'Intégration Continue est tout autant une mentalité que des outils.
    Pour tirer un maximum de profit de l'IC, une équipe doit adopter un
    comportement IC. Par exemple, vos projets doivent avoir un build fiable,
    reproductible et automatisé, sans intervention humaine. La correction les builds 
    en erreur devrait être une priorité absolue, et ne devrait pas être oubliée 
    dans un coin. Le processus de déploiement devrait être automatisé,
    sans étapes manuelles. Et puisque la confiance que vous mettez dans 
    votre serveur d'intégration dépend en grande partie de la qualité de 
    vos tests, l'équipe doit mettre l'accent sur la qualité des tests et 
    des pratiques associées.</para>
    <para>Dans ce livre nous verrons comment mettre en œuvre une solution
    d'Intégration Continue robuste et complète avec Jenkins<indexterm id="I_indexterm1_d1e596" class="endofrange" startref="ch01-ci" significance="normal"><primary/></indexterm> ou Hudson.</para>
  </sect1>
  <sect1 id="intro-sect-introducing-jenkins">
    <title>Introduction à Jenkins (né Hudson)</title>
    <para>Jenkins, <indexterm class="startofrange" id="ch01-jenkins" significance="normal"><primary>Jenkins</primary></indexterm>qui s'appelait à l'origine <indexterm id="I_indexterm1_d1e608" significance="normal"><primary>Hudson</primary><seealso>Jenkins</seealso></indexterm>Hudson, est un outil d'Intégration Continue 
    open source écrit en Java. Bénéficiant d'une part de marché dominante, 
    Jenkins est utilisé par des équipes de toutes tailles, pour des projets 
    dans des langages et des technologies variés, incluant .NET, Ruby, 
    Groovy, Grails, PHP et d'autres, ainsi que Java bien sûr. Qu'est ce 
    qui est à l'origine du succès de Jenkins ? Pourquoi utiliser Jenkins
    pour votre infrastructure d'IC ?</para>
    <para>Tout d'abord, Jenkins est faicle à utiliser. L'interface utilisateur
    est simple, inuitive et visuellement agréable, et Jenkins dans son ensemble
    à une très petite courbe d'apprentissage. Comme nous le verrons dans 
    le chapitre suivant, vous pouvez démarrer avec jenkins en quelques 
    minutes.</para>
    <para>Cependant jenkins n'a pas sacrifié puissance ou extensibilité : il est aussi
    extrêmement flexible et s'adapte facilement à vos moindres désirs. Des 
    centaines d'extensions open source sont disponibles, et de nouvelles 
    aparaissent toutes les semaines. Ces extensions couvrent tout depuis les
    outils de gestion de configuration, les outils de build, les métriques de
    qualité de code, les annonceurs de build, l'intégration avec des 
    systèmes externes, la personalisation de l'interface utilisateur, des 
    jeux et d'autres encore. Les installer est simple et rapide.</para>
    <para>Enfin, mais ce n'est pas négligeable, une bonne part de la 
    popularité de Jenkins vient de la taille <phrase role="keep-together">et</phrase> du
    dynamisme de sa communauté. La communauté Jenkins est immense, dynamique, 
    réactive et c'est un groupe<phrase role="keep-together">accueillant</phrase>, avec
    ses champions passionnés, ses listes de diffusion actives, ses canaux IRC et 
    son blog et son compte twitter très bruyants. Le rythme de développement
    est très intense, avec des livraisons hebdomadaires comportant les dernières
    évolutions, corrections et mises à jour des extensions.</para>
    <para>Cependant, Jenkins répond aussi bien aux attentes desutilisateurs qui ne 
    souhaitent pas mettre à jour toutes les semaines. However Jenkins also caters to users who are not comfortable with
    upgrading on a weekly basis. Pour ceux qui veulent un rythme moins trépidant,
    il existe une version Long-term Support, ou <indexterm id="I_indexterm1_d1e628" significance="normal"><primary>livraisons LTS (Long-Term Support)</primary></indexterm>LTS, un ensemble
    de versions qui sont à la traine par rapport à la dernière en termes de nouveautés 
    mais qui apportent plus de stabilité et moins de changements. Les versions LTS
    sortent environ tous les trois mois, les correctifs importants y sont 
    intégrés. Ce concept est identique aux <phrase role="keep-together">versions</phrase> Ubuntu LTS .</para>
  </sect1>
  <sect1 id="intro-sect-history">
    <title>De Hudosn à Jenkins — Un rapide historique</title>
    <para>Jenkins<indexterm class="startofrange" id="ch01-history" significance="normal"><primary>Jenkins</primary><secondary>history of</secondary></indexterm> is the result of one visionary developer, <indexterm id="I_indexterm1_d1e646" significance="normal"><primary>Kawaguchi, Kohsuke (developer of Hudson)</primary></indexterm>Kohsuke Kawaguchi, who started the project as a hobby
    project under the name of <indexterm id="I_indexterm1_d1e650" significance="normal"><primary>Hudson</primary></indexterm>Hudson in late 2004 whilst working at Sun. As Hudson evolved
    over the years, it was adopted by more and more teams within Sun for their
    own projects. By early 2008, Sun recognized the quality and value of the
    tool, and ask Kohsuke to work on Hudson full-time, starting to provide
    professional services and support around Hudson. By 2010, Hudson had
    become the leading Continuous Integration solution with a market share of
    over 70%.</para>
    <para>In 2009, Oracle purchased Sun. Towards the end of 2010, tensions
    arose between the Hudson developer community and Oracle, initially
    triggered by problems with the Java.net infrastructure, and aggravated by
    issues related to Oracle’s claim to the Hudson trademark. These tensions
    also reflected strong underlying disagreements about the way the project
    was being managed by Oracle. Indeed, Oracle wanted to move towards a more
    strictly controlled development process with a slower release schedule,
    whereas most of the core Hudson developers, led by Kohsuke, preferred to
    continue with the open, flexible, and fast-paced community-focused model
    that had worked so well for Hudson in the past.</para>
    <para>In January 2011, the Hudson developer community decisively voted to
    rename the project to Jenkins. They subsequently migrated the original
    Hudson code base to a new <indexterm id="I_indexterm1_d1e658" significance="normal"><primary>GitHub project</primary></indexterm><ulink url="https://github.com/jenkinsci">GitHub
    project</ulink> and continued their work there. The vast majority of core
    and plugin developers upped camp and followed Kohsuke Kawaguchi and other
    core contributors to the Jenkins camp, where the bulk of the development
    activity can be seen today.</para>
    <para>After the fork, a majority of users also followed the Jenkins
    developer community and switched to Jenkins. At the time of writing, polls
    show that some 75% of Hudson users had switched to Jenkins, while 13% were
    still using Hudson, and another 12% were using both Hudson and Jenkins or
    in the process of migrating to Jenkins.</para>
    <para>Nevertheless, Oracle and Sonatype (the company behind Maven and
    Nexus) have continued to work on the Hudson code base (now also hosted on
    GitHub at <ulink url="https://github.com/hudson"/>), but with a
    very different focus. Indeed, the <indexterm id="I_indexterm1_d1e670" significance="normal"><primary>Sonatype tools</primary></indexterm>Sonatype developers have concentrating on major underlying
    infrastructure changes around, among other areas, Maven integration, the
    dependency injection framework and the plugin <indexterm id="I_indexterm1_d1e674" class="endofrange" startref="ch01-jenkins" significance="normal"><primary/></indexterm><indexterm id="I_indexterm1_d1e676" class="endofrange" startref="ch01-history" significance="normal"><primary/></indexterm>architecture.</para>
  </sect1>
  <sect1 id="intro-sect-jenkins-or-hudson">
    <title>Should I Use Jenkins or Hudson?</title>
    <para>So should<indexterm id="I_indexterm1_d1e684" significance="normal"><primary>Jenkins</primary><secondary>reasons to use</secondary></indexterm> you use Jenkins or Hudson? Since this is a book on Jenkins,
    here are a few reasons why you might want to opt for Jenkins:</para>
    <itemizedlist>
      <listitem>
        <para><emphasis>Jenkins is the new Hudson.</emphasis> In fact, Jenkins
        is simply the old Hudson with a new name, so if you liked Hudson,
        you’ll like Jenkins! Jenkins uses the Hudson code base, and the
        development team and project philosophy remain the same. In a
        nutshell, the original developers, who wrote the vast majority of the
        Hudson core, simply resumed business as usual after the fork working
        on the Jenkins project.</para>
      </listitem>
      <listitem>
        <para><emphasis>The Jenkins <indexterm id="I_indexterm1_d1e700" significance="normal"><primary>Jenkins</primary><secondary>community for</secondary></indexterm>community</emphasis>. Like many of the more successful
        <indexterm id="I_indexterm1_d1e707" significance="normal"><primary>Jenkins</primary><secondary sortas="Open Source">as Open Source project</secondary></indexterm>Open Source projects, much of Hudson’s strength came
        from its large and dynamic community, and its massive adoption. Bugs
        are identified (and generally fixed) much more rapidly, and, if you
        have a problem, chances are someone else will have had it too! If you
        run into trouble, post a question on the mailing list or IRC
        channel—there’s sure to be someone who can help.</para>
      </listitem>
      <listitem>
        <para><emphasis>The fast <indexterm id="I_indexterm1_d1e717" significance="normal"><primary>Jenkins</primary><secondary>rapid release cycle of</secondary></indexterm>development pace</emphasis>. Jenkins continues the rapid
        release cycles that typified Hudson, which many developers love. New
        features, new plugins and bug fixes come out weekly, and the
        turn-around time for bug fixes can be very short indeed. And, if you
        prefer more stability, there are always the LTS releases</para>
      </listitem>
    </itemizedlist>
    <para>And, <indexterm id="I_indexterm1_d1e726" significance="normal"><primary>Hudson</primary></indexterm>in the interest of balance, here are some reasons you might
    prefer to stick with Hudson:</para>
    <itemizedlist>
      <listitem>
        <para><emphasis>If it ain’t broke, don’t fix it.</emphasis> You
        already have a Hudson installation that you are happy with, and don’t
        feel the need to upgrade to the latest version.</para>
      </listitem>
      <listitem>
        <para><emphasis>Enterprise integration and <indexterm id="I_indexterm1_d1e740" significance="normal"><primary>Sonatype tools</primary></indexterm>Sonatype tools.</emphasis> Hudson is likely to place a
        strong emphasis on integration with enterprise tools such as
        <indexterm id="I_indexterm1_d1e745" significance="normal"><primary>LDAP/Active Directory</primary></indexterm>LDAP/Active Directory, and the Sonatype products such as
        <indexterm id="I_indexterm1_d1e749" significance="normal"><primary>Maven</primary><secondary>Hudson support for</secondary></indexterm>Maven 3, <indexterm id="I_indexterm1_d1e755" significance="normal"><primary>Nexus</primary><secondary>Hudson support for</secondary></indexterm>Nexus and <indexterm id="I_indexterm1_d1e761" significance="normal"><primary>M2Eclipse</primary></indexterm>M2Ecipse, whereas Jenkins is more open to other
        competing tools such as <indexterm id="I_indexterm1_d1e765" significance="normal"><primary>Artifactory</primary><secondary>Jenkins support for</secondary></indexterm>Artifactory and <indexterm id="I_indexterm1_d1e772" significance="normal"><primary>Gradle</primary><secondary>Jenkins support for</secondary></indexterm>Gradle.</para>
      </listitem>
      <listitem>
        <para><emphasis>Plugin <indexterm id="I_indexterm1_d1e782" significance="normal"><primary>plugins</primary><secondary>architecture of, Jenkins compared to Hudson</secondary></indexterm>architecture.</emphasis> If you intend to write your own
        Jenkins/Hudson plugins, you should be aware that Sonatype is working
        on providing JSR-330 dependency injection for Hudson plugins. New
        developers may find this approach easier to use, though it does raise
        issues about future plugin compatibility between Jenkins and
        Hudson.</para>
      </listitem>
    </itemizedlist>
    <para>The good news is, no matter whether you are using Jenkins or Hudson,
    the products remain very similar, and the vast majority of techniques and
    tips discussed in this book will apply equally well to both. Indeed, to
    illustrate this point, many screenshots in this book refer to Hudson
    rather than Jenkins.</para>
  </sect1>
  <sect1 id="intro-sect-your-organization">
    <title>Introducing Continuous Integration into Your Organization</title>
    <para>Continuous Integration<indexterm class="startofrange" id="ch01-phases" significance="normal"><primary>CI (Continuous Integration)</primary></indexterm> is not an all-or-nothing affair. In fact, introducing CI
    into an organization takes you on a path that progresses through several
    distinct phases. Each of these phases involves incremental improvements to
    the technical infrastructure as well as, perhaps more importantly,
    improvements in the practices and culture of the development team itself.
    In the following paragraphs, I have tried to paint an approximate picture
    of each phase.</para>
    <sect2>
      <title>Phase 1—No Build Server</title>
      <para>Initially, the team has no central <indexterm id="I_indexterm1_d1e805" significance="normal"><primary>build server</primary></indexterm>build server of any kind. Software is built manually on a
      developer’s machine, though it may use an Ant script or similar to do
      so. Source code may be stored in a central source code repository, but
      developers do not necessarily commit their changes on a regular basis.
      Some time before a release is scheduled, a developer manually integrates
      the changes, a process which is generally associated with pain and
      suffering.</para>
    </sect2>
    <sect2>
      <title>Phase 2—Nightly Builds</title>
      <para>In this phase, the team has a build server, and <indexterm id="I_indexterm1_d1e814" significance="normal"><primary>automated nightly builds</primary></indexterm><indexterm id="I_indexterm1_d1e817" significance="normal"><primary>nightly builds</primary><see>automated nightly builds</see></indexterm>automated builds are scheduled on a regular (typically
      nightly) basis. This build simply compiles the code, as there are no
      reliable or repeatable unit tests. Indeed, automated tests, if they are
      written, are not a mandatory part of the build process, and may well not
      run correctly at all. However developers now commit their changes
      regularly, at least at the end of every day. If a developer commits code
      changes that conflict with another developer’s work, the build server
      alerts the team via email the following morning. Nevertheless, the team
      still tends to use the build server for information purposes only—they
      feel little obligation to fix a broken build immediately, and builds may
      stay broken on the build server for some time.</para>
    </sect2>
    <sect2>
      <title>Phase 3—Nightly Builds and Basic Automated Tests</title>
      <para>The team<indexterm id="I_indexterm1_d1e828" significance="normal"><primary>tests</primary><secondary>automating</secondary></indexterm> is now starting to take Continuous Integration and
      automated testing more seriously. The build server is configured to kick
      off a build whenever new code is committed to the version control
      system, and team members are able to easily see what changes in the
      source code triggered a particular build, and what issues these changes
      address. In addition, the build script compiles the application and runs
      a set of automated unit and/or integration tests. In addition to email,
      the build server also alerts team members of integration issues using
      more proactive channels such as Instant Messaging. Broken builds are now
      generally fixed quickly.</para>
    </sect2>
    <sect2>
      <title>Phase 4—Enter the Metrics</title>
      <para>Automated <indexterm id="I_indexterm1_d1e839" significance="normal"><primary>code quality metrics</primary></indexterm><indexterm id="I_indexterm1_d1e842" significance="normal"><primary>code coverage metrics</primary></indexterm><indexterm id="I_indexterm1_d1e845" significance="normal"><primary>metrics</primary><see>reporting</see></indexterm><indexterm id="I_indexterm1_d1e850" significance="normal"><primary>reporting</primary><secondary>code coverage metrics</secondary></indexterm><indexterm id="I_indexterm1_d1e855" significance="normal"><primary>reporting</primary><secondary>code quality metrics</secondary></indexterm>code quality and code coverage metrics are now run to help
      evaluate the quality of the code base and (to some extent, at least) the
      relevance and effectiveness of the tests. The code quality build also
      automatically generates API documentation for the application. All this
      helps teams keep the quality of the code base high, alerting team
      members if good testing practices are slipping. The team has also set up
      a “build radiator,” a dashboard view of the project status that is
      displayed on a prominent screen visible to all team members.</para>
    </sect2>
    <sect2>
      <title>Phase 5—Getting More Serious About Testing</title>
      <para>The <indexterm id="I_indexterm1_d1e866" significance="normal"><primary>Test-Driven development</primary></indexterm><indexterm id="I_indexterm1_d1e869" significance="normal"><primary>tests</primary><secondary>Test-Driven development</secondary></indexterm>benefits of Continuous Integration are closely related to
      solid testing practices. Now, practices like Test-Driven Development are
      more widely practiced, resulting in a growing confidence in the results
      of the automated builds. The application is no longer simply compiled
      and tested, but if the tests pass, it is automatically deployed to an
      application server for more comprehensive end-to-end tests and
      performance tests.</para>
    </sect2>
    <sect2>
      <title>Phase 6—Automated Acceptance Tests and More Automated <phrase role="keep-together">Deployment</phrase></title>
      <para>Acceptance-Test Driven Development<indexterm id="I_indexterm1_d1e882" significance="normal"><primary>acceptance tests, automated</primary></indexterm><indexterm id="I_indexterm1_d1e885" significance="normal"><primary>Acceptance-Test Driven Development</primary></indexterm><indexterm id="I_indexterm1_d1e888" significance="normal"><primary>tests</primary><secondary>acceptance tests</secondary></indexterm><indexterm id="I_indexterm1_d1e893" significance="normal"><primary>tests</primary><secondary>automating</secondary></indexterm><indexterm id="I_indexterm1_d1e898" significance="normal"><primary>automated tests</primary><see>tests</see></indexterm> is practiced, guiding development efforts and providing
      high-level reporting on the state of the project. These automated tests
      use Behavior-Driven Development and Acceptance-Test Driven Development
      tools to act as communication and documentation tools and documentation
      as much as testing tools, publishing reports on test results in business
      terms that non-developers can understand. Since these high-level tests
      are automated at an early stage in the development process, they also
      provide a clear idea of what features have been implemented, and which
      remain to be done. The application is automatically deployed into test
      environments for testing by the QA team either as changes are committed,
      or on a nightly basis; a version can be deployed (or “promoted”) to UAT
      and possibly production environments using a manually-triggered build
      when testers consider it ready. The team is also capable of using the
      build server to back out a release, rolling back to a previous release,
      if something goes horribly wrong.</para>
    </sect2>
    <sect2>
      <title>Phase 7—Continuous Deployment</title>
      <para>Confidence<indexterm id="I_indexterm1_d1e909" significance="normal"><primary>continuous deployment</primary></indexterm> in the automated unit, integration and acceptance tests
      is now such that teams can apply the automated deployment techniques
      developed in the previous phase to push out new changes directly into
      production.</para>
      <?dbfo-need height=”1in”?>
      <para>The progression between levels here is of course somewhat
      approximate, and may not always match real-world situations. For
      example, you may well introduce automated web tests before integrating
      code quality and code coverage reporting. However, it should give a
      general idea of how implementing a Continuous Integration strategy in a
      real world organization generally<indexterm id="I_indexterm1_d1e916" class="endofrange" startref="ch01-phases" significance="normal"><primary/></indexterm> works.</para>
    </sect2>
  </sect1>
  <sect1 id="I_sect11_d1e919">
    <title>Where to Now?</title>
    <para>Throughout the remainder of this book, as we study the various
    features Jenkins has to offer, as well as the practices required to make
    the most of these features, we will see how we can progress through each
    of these levels with Jenkins. And remember, most of the examples used in
    the book are available online (see <ulink url="http://www.wakaleo.com/books/jenkins-the-definitive-guide"/>
    for more details), so you can get your hands dirty too!</para>
  </sect1>
</chapter>
